use crate::error::{FizzBuzzError, Result};

#[derive(Debug)]
pub struct Rule {
    conditions: Vec<Condition>,
    /// Output kind to be generated by this `Rule`
    pub token: RawToken,
    pub priority: u32,
}

impl Rule {
    pub fn new(conditions: Vec<Condition>, token: RawToken, priority: u32) -> Result<Self> {
        let multiple_consecutive_in_rule = conditions
            .iter()
            .filter(|c| {
                matches!(
                    c,
                    Condition::Consecutive {
                        rivals: _,
                        divisor: _,
                    }
                )
            })
            .count()
            > 1;
        if multiple_consecutive_in_rule {
            return Err(FizzBuzzError::InvalidRuleConfiguration(
                "Each rule can have at most one \
                consecutive condition!"
                    .to_string(),
            ));
        }
        Ok(Self {
            conditions,
            token,
            priority,
        })
    }

    pub fn default_rule_set(f: u32, b: u32) -> Vec<Self> {
        vec![
            Self {
                conditions: vec![Condition::Value],
                token: RawToken::Value,
                priority: 0,
            },
            Self {
                conditions: vec![Condition::Consecutive {
                    divisor: f,
                    rivals: vec![b],
                }],
                token: RawToken::Fizz,
                priority: 1,
            },
            Self {
                conditions: vec![Condition::Consecutive {
                    divisor: b,
                    rivals: vec![f],
                }],
                token: RawToken::Buzz,
                priority: 1,
            },
            Self {
                conditions: vec![Condition::Divisor(f), Condition::Divisor(b)],
                token: RawToken::FizzBuzz,
                priority: 2,
            },
        ]
    }

    pub fn validate_rule_set(rules: &[Self]) -> Result<()> {
        if rules.is_empty() {
            return Err(FizzBuzzError::InvalidRuleConfiguration(
                "Rule set can not be empty".to_string(),
            ));
        }

        // Check that each rule contains at most one `Condition::Consecutive` element.
        for r in rules {
            let multiple_consecutive_in_rule = r
                .conditions
                .iter()
                .filter(|c| {
                    matches!(
                        c,
                        Condition::Consecutive {
                            rivals: _,
                            divisor: _,
                        }
                    )
                })
                .count()
                > 1;
            if multiple_consecutive_in_rule {
                return Err(FizzBuzzError::InvalidRuleConfiguration(
                    "Each rule can have at most one \
                        consecutive condition!"
                        .to_string(),
                ));
            }
        }

        Ok(())
    }

    pub fn try_tokenize(&self, i: u32) -> Result<Option<Token>> {
        let mut met_count = 0;
        let mut maybe_consecutive = None;

        // TODO: Maybe could be done by implementing condition checking on the Conditions enum
        //       with a flexible trait.
        //       Would this be worth the increased complexity?
        for c in &self.conditions {
            let this_condition_met = match c {
                Condition::Value => true,
                Condition::Divisor(d) => i % d == 0,
                Condition::Consecutive { rivals, divisor } => {
                    maybe_consecutive =
                        Some(Rule::calculate_uninterrupted_divisions(i, *divisor, rivals));
                    maybe_consecutive.expect("Some value set!") > 0
                }
            };
            if this_condition_met {
                met_count += 1;
            }
        }
        if met_count != self.conditions.len() {
            return Ok(None);
        }
        Self::tokenize_raw_token(i, self.token, maybe_consecutive).map(Some)
    }

    /// Calculates the number of clean divisions within 1..=i of `divisor`, up to the last
    /// clean division of the range by any member of `rivals`.
    /// Returns `0`, if the current iteration `i` can not be cleanly divided by `divisor`.
    ///
    /// I.e. for `i = 8`, `divisor = 2` and `rivals = &[5]`:
    ///     -   prior to 8, which is cleanly divided by `divisor`, `divisor` also divides
    ///         6 cleanly. As between 8 and 6 no `rival` divides any number cleanly, the number
    ///         of uninterrupted clean divisions is 2 (one at 8, the other one at 6).
    ///         The next clean division at 4 is interrupted by the rival's clean division of 5.
    ///
    /// # Panics
    /// This function assumes nor `divisor` neither any member of `rivals`
    /// is equal to zero and panics, if this it not the case.
    fn calculate_uninterrupted_divisions(i: u32, divisor: u32, rivals: &[u32]) -> usize {
        if i % divisor != 0 {
            return 0;
        }

        // first clean division
        if divisor == i {
            return 1;
        }

        // no rivals
        if rivals.is_empty() {
            return (i / divisor) as usize;
        }

        // If the smallest rival is already bigger than the current iteration, we can skip the check.
        if i < *rivals.iter().min().unwrap_or(&0) {
            let total_divisions = i / divisor;
            return total_divisions as usize; // save conversion on targets with at least 32 bit arch.
        }

        let mut uninterrupted_clean_division: Option<u32> = None;

        for r in rivals {
            let mut last_clean_divide_by_rival = None;
            // Check backwards for clean divisions
            for iteration in (1..=i).rev() {
                if iteration % r == 0 {
                    last_clean_divide_by_rival = Some(iteration);
                    break;
                }
            }

            // if there was a prior clean division by a rival, the number of uninterrupted
            // clean divisions by `divisor` is the number of times `divisor` fits between
            // the rivals last clean division and `i` plus one.
            if let Some(rival_division) = last_clean_divide_by_rival {
                let delta = i - rival_division;

                // check for the "FizzBuzz" case, where the last clean division by a rival is also
                // a clean division by divisor. This is considered an interrupt.
                let fizz_buzz = delta % divisor == 0;

                uninterrupted_clean_division = if let Some(v) = uninterrupted_clean_division {
                    Some(v.min((delta / divisor) + !fizz_buzz as u32))
                } else {
                    Some((delta / divisor) + !fizz_buzz as u32)
                };
            }
        }
        uninterrupted_clean_division.unwrap_or(0) as usize
    }

    fn tokenize_raw_token(
        i: u32,
        raw_token: RawToken,
        maybe_consecutive: Option<usize>,
    ) -> Result<Token> {
        let err_msg = |s: &str| {
            format!(
                "The {s} token requires a `Consecutive` \
        condition to be configured in its rule"
            )
        };

        let token = match raw_token {
            RawToken::Value => Token::Value { v: i },
            RawToken::Fizz => {
                let consecutive = maybe_consecutive
                    .ok_or(FizzBuzzError::InvalidTokenConfiguration(err_msg("Fizz")))?;
                Token::Fizz { consecutive }
            }
            RawToken::Buzz => {
                let consecutive = maybe_consecutive
                    .ok_or(FizzBuzzError::InvalidTokenConfiguration(err_msg("Buzz")))?;
                Token::Buzz { consecutive }
            }
            RawToken::FizzBuzz => Token::FizzBuzz,
        };
        Ok(token)
    }
}

#[derive(Debug)]
pub enum Condition {
    Value,
    Divisor(u32),
    /// The `Consecutive` condition is met, when the current iteration `i`
    /// is divided cleanly by the `divisor` and if none of its `rivals`
    /// have divided any prior iteration cleanly before the last clean
    /// division by `divisor`.
    /// I.e: `Condition::Consecutive { divisor: 2, rivals: vec![7, 9]}` is
    /// met on iteration 6, as the `divisor` divided a prior iteration
    /// (2 and 4 in this case) cleanly, without any clean division by any of
    /// its rival divisors contained in `rivals`.
    Consecutive {
        divisor: u32,
        rivals: Vec<u32>,
    },
}

#[derive(Debug, Clone, Copy)]
pub enum Token {
    Value { v: u32 },
    Fizz { consecutive: usize },
    Buzz { consecutive: usize },
    FizzBuzz,
}

impl std::fmt::Display for Token {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Token::Value { v } => write!(f, "{v}"),
            Token::Fizz { consecutive } => {
                write!(f, "Fizz{}", "+".repeat(consecutive.saturating_sub(1)))
            }
            Token::Buzz { consecutive } => {
                write!(f, "Buzz{}", "+".repeat(consecutive.saturating_sub(1)))
            }
            Token::FizzBuzz => write!(f, "FizzBuzz"),
        }
    }
}

#[derive(Debug, Copy, Clone)]
pub enum RawToken {
    Value,
    Fizz,
    Buzz,
    FizzBuzz,
}

#[cfg(test)]
mod test {
    use super::Rule;
    use pretty_assertions::assert_eq;
    #[test]
    fn test_uninterrupted_divisions() {
        // ------------------------- Divisor does not divide `i` ------------------------- //
        let res = Rule::calculate_uninterrupted_divisions(7, 2, &vec![7]);
        let expected = 0;
        assert_eq!(res, expected);

        // --------------------- No prior rival clean divisions  ------------------------- //
        let res = Rule::calculate_uninterrupted_divisions(6, 2, &vec![7]);
        let expected = 3;
        assert_eq!(res, expected);

        // ---------------------  Interrupted directly before   ------------------------- //
        let res = Rule::calculate_uninterrupted_divisions(8, 2, &vec![3]);
        let expected = 1;
        assert_eq!(res, expected);

        // ---------------------   Rival smaller than divisor   ------------------------- //
        let res = Rule::calculate_uninterrupted_divisions(10, 5, &vec![3]);
        let expected = 1;
        assert_eq!(res, expected);

        // ---------------------  Iteration before any division ------------------------- //
        let res = Rule::calculate_uninterrupted_divisions(3, 5, &vec![6]);
        let expected = 0;
        assert_eq!(res, expected);

        // ---------------------   Check at FizzBuzz condition  ------------------------- //
        let res = Rule::calculate_uninterrupted_divisions(6, 2, &vec![3]);
        let expected = 0;
        assert_eq!(res, expected);

        // --------------------- Second rival interrupts first  ------------------------- //
        let res = Rule::calculate_uninterrupted_divisions(8, 2, &vec![9, 5]);
        let expected = 2;
        assert_eq!(res, expected);

        // ---------------------     FizzBuzz second rival      ------------------------- //
        let res = Rule::calculate_uninterrupted_divisions(10, 2, &vec![9, 5]);
        let expected = 0;
        assert_eq!(res, expected);

        // --------------------- FizzBuzz interrupt second rival ------------------------ //
        let res = Rule::calculate_uninterrupted_divisions(24, 2, &vec![9, 5]);
        let expected = 2;
        assert_eq!(res, expected);

        // ---------------------           No rivals             ------------------------ //
        let res = Rule::calculate_uninterrupted_divisions(24, 2, &vec![]);
        let expected = 12;
        assert_eq!(res, expected);

        // --------------          No division at checked iteration        -------------- //
        let res = Rule::calculate_uninterrupted_divisions(25, 2, &vec![]);
        let expected = 0;
        assert_eq!(res, expected);
    }
}
